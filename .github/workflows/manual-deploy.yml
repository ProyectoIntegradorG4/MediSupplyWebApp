name: Despliegue Manual a AWS

on:
  workflow_dispatch:
    inputs:
      tag:
        description: 'Tag de la versiÃ³n a desplegar (ej: 2024.01.15-abc1234)'
        required: true
        type: string
      environment:
        description: 'Ambiente de despliegue'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging
      confirm_deployment:
        description: 'Â¿Confirmar despliegue?'
        required: true
        default: false
        type: boolean

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: medisupply-webapp
  ECS_SERVICE: medisupply-service
  ECS_CLUSTER: medisupply-cluster
  ECS_TASK_DEFINITION: medisupply-task-definition

jobs:
  validate-inputs:
    name: Validar Entradas
    runs-on: ubuntu-latest
    outputs:
      should-deploy: ${{ steps.validate.outputs.should-deploy }}
      image-tag: ${{ steps.validate.outputs.image-tag }}
    
    steps:
    - name: Validar confirmaciÃ³n
      id: validate
      run: |
        if [ "${{ github.event.inputs.confirm_deployment }}" != "true" ]; then
          echo "âŒ Despliegue no confirmado. Marca 'Confirmar despliegue' para continuar."
          echo "should-deploy=false" >> $GITHUB_OUTPUT
          exit 1
        fi
        
        echo "âœ… Despliegue confirmado"
        echo "should-deploy=true" >> $GITHUB_OUTPUT
        
        # Construir el tag de la imagen Docker
        IMAGE_TAG="${{ github.event.inputs.tag }}"
        echo "image-tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
        echo "Tag de imagen: $IMAGE_TAG"

  deploy-to-aws:
    name: Desplegar en AWS ECS
    runs-on: ubuntu-latest
    needs: validate-inputs
    if: needs.validate-inputs.outputs.should-deploy == 'true'
    
    steps:
    - name: Checkout del cÃ³digo
      uses: actions/checkout@v4
      
    - name: Configurar AWS CLI
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: Verificar que la imagen existe en ECR
      run: |
        echo "Verificando imagen: ${{ needs.validate-inputs.outputs.image-tag }}"
        aws ecr describe-images \
          --repository-name ${{ env.ECR_REPOSITORY }} \
          --image-ids imageTag=${{ needs.validate-inputs.outputs.image-tag }} \
          --region ${{ env.AWS_REGION }}
        echo "âœ… Imagen encontrada en ECR"
        
    - name: Descargar definiciÃ³n de tarea actual
      run: |
        aws ecs describe-task-definition \
          --task-definition ${{ env.ECS_TASK_DEFINITION }} \
          --query taskDefinition > task-definition.json
        echo "âœ… DefiniciÃ³n de tarea descargada"
          
    - name: Actualizar imagen en definiciÃ³n de tarea
      run: |
        # Construir la URI completa de la imagen
        ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
        IMAGE_URI="$ACCOUNT_ID.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:${{ needs.validate-inputs.outputs.image-tag }}"
        
        echo "Actualizando imagen a: $IMAGE_URI"
        
        # Actualizar la definiciÃ³n de tarea con la nueva imagen
        jq --arg IMAGE "$IMAGE_URI" \
          '.containerDefinitions[0].image = $IMAGE' \
          task-definition.json > updated-task-definition.json
          
        echo "âœ… DefiniciÃ³n de tarea actualizada"
          
    - name: Registrar nueva definiciÃ³n de tarea
      run: |
        NEW_TASK_DEF=$(aws ecs register-task-definition \
          --cli-input-json file://updated-task-definition.json \
          --query 'taskDefinition.taskDefinitionArn' \
          --output text)
        echo "NEW_TASK_DEF=$NEW_TASK_DEF" >> $GITHUB_ENV
        echo "âœ… Nueva definiciÃ³n de tarea registrada: $NEW_TASK_DEF"
          
    - name: Actualizar servicio ECS
      run: |
        aws ecs update-service \
          --cluster ${{ env.ECS_CLUSTER }} \
          --service ${{ env.ECS_SERVICE }} \
          --task-definition $NEW_TASK_DEF
        echo "âœ… Servicio ECS actualizado"
          
    - name: Esperar estabilizaciÃ³n del servicio
      run: |
        echo "Esperando estabilizaciÃ³n del servicio..."
        aws ecs wait services-stable \
          --cluster ${{ env.ECS_CLUSTER }} \
          --services ${{ env.ECS_SERVICE }}
        echo "âœ… Servicio estabilizado"
          
    - name: Verificar despliegue
      run: |
        # Obtener informaciÃ³n del servicio
        SERVICE_INFO=$(aws ecs describe-services \
          --cluster ${{ env.ECS_CLUSTER }} \
          --services ${{ env.ECS_SERVICE }} \
          --query 'services[0]')
        
        RUNNING_COUNT=$(echo $SERVICE_INFO | jq -r '.runningCount')
        DESIRED_COUNT=$(echo $SERVICE_INFO | jq -r '.desiredCount')
        
        echo "Tareas ejecutÃ¡ndose: $RUNNING_COUNT/$DESIRED_COUNT"
        
        if [ "$RUNNING_COUNT" -eq "$DESIRED_COUNT" ]; then
          echo "âœ… Despliegue exitoso - Todas las tareas estÃ¡n ejecutÃ¡ndose"
        else
          echo "âŒ Despliegue incompleto - Algunas tareas no estÃ¡n ejecutÃ¡ndose"
          exit 1
        fi
          
    - name: Notificar despliegue exitoso
      run: |
        echo "ðŸŽ‰ Â¡Despliegue completado exitosamente!"
        echo "ðŸ“¦ Imagen: ${{ needs.validate-inputs.outputs.image-tag }}"
        echo "ðŸ·ï¸ Tag: ${{ github.event.inputs.tag }}"
        echo "ðŸŒ Ambiente: ${{ github.event.inputs.environment }}"
        echo "â° Timestamp: $(date)"
        
        # Obtener URL del servicio si estÃ¡ disponible
        SERVICE_URL=$(aws ecs describe-services \
          --cluster ${{ env.ECS_CLUSTER }} \
          --services ${{ env.ECS_SERVICE }} \
          --query 'services[0].loadBalancers[0].targetGroupArn' \
          --output text 2>/dev/null || echo "No disponible")
        
        if [ "$SERVICE_URL" != "No disponible" ]; then
          echo "ðŸ”— Servicio desplegado correctamente"
        fi
